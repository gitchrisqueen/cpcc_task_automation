#  Copyright (c) 2024. Christopher Queen Consulting LLC (http://www.ChristopherQueenConsulting.com/)
import datetime as DT

import dateparser
import pytest

from cqc_cpcc.utilities.date import (
    is_checkdate_before_date,
    is_checkdate_after_date,
    is_date_in_range,
    weeks_between_dates,
)


# Generated by CodiumAI


class TestIsCheckdateBeforeDate:

    @pytest.mark.unit
    # check_date and before_date are both datetime objects and check_date is before before_date
    def test_checkdate_before_beforedate_datetime(self):
        check_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        before_date = DT.datetime(2023, 1, 2, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == True

    @pytest.mark.unit
    # check_date and before_date are the same datetime object
    def test_checkdate_equals_beforedate_datetime(self):
        check_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        before_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == False

    @pytest.mark.unit
    # check_date and before_date are the same date object
    def test_checkdate_equals_beforedate_date(self):
        check_date = DT.date(2023, 1, 1)
        before_date = DT.date(2023, 1, 1)
        assert is_checkdate_before_date(check_date, before_date) == False

    @pytest.mark.unit
    # check_date and before_date are both date objects and check_date is before before_date
    def test_checkdate_before_beforedate_date(self):
        check_date = DT.date(2023, 1, 1)
        before_date = DT.date(2023, 1, 2)
        assert is_checkdate_before_date(check_date, before_date) == True

    @pytest.mark.unit
    # check_date is a datetime object and before_date is a date object, and check_date is before before_date
    def test_checkdate_before_beforedate_datetime(self):
        check_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        before_date = DT.datetime(2023, 1, 2, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == True

    @pytest.mark.unit
    # check_date is a date object and before_date is a datetime object, and check_date is before before_date
    def test_checkdate_before_beforedate_datetime(self):
        check_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        before_date = DT.datetime(2023, 1, 2, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == True

    @pytest.mark.unit
    # check_date is a datetime object and before_date is a date object, and check_date is the same as before_date
    def test_checkdate_same_as_beforedate(self):
        check_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        before_date = DT.datetime(2023, 1, 1)
        assert is_checkdate_before_date(check_date, before_date) == True

    @pytest.mark.unit
    # check_date is a date object and before_date is a datetime object, and check_date is the same as before_date
    def test_checkdate_same_as_beforedate(self):
        check_date = DT.datetime(2023, 1, 1, 12, 0, 0).date()
        before_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == False

    @pytest.mark.unit
    # check_date is after before_date
    def test_checkdate_after_beforedate_datetime(self):
        check_date = DT.datetime(2023, 1, 2, 12, 0, 0)
        before_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == False

    @pytest.mark.unit
    # check_date is a date object and before_date is a datetime object, and check_date is after before_date
    def test_checkdate_after_beforedate_datetime(self):
        check_date = DT.date(2023, 1, 2)
        before_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == False

    @pytest.mark.unit
    # check_date is a string that can be parsed to a date
    def test_checkdate_before_beforedate_string(self):
        check_date = dateparser.parse("2023-01-01")
        before_date = DT.datetime(2023, 1, 2, 12, 0, 0)
        assert is_checkdate_before_date(check_date, before_date) == True

    @pytest.mark.unit
    # before_date is a string that can be parsed to a date
    def test_before_date_string_parsable_to_date(self):
        check_date = DT.datetime(2023, 1, 1, 12, 0, 0)
        before_date = dateparser.parse("2023-01-02 12:00:00")
        assert is_checkdate_before_date(check_date, before_date) == True

    @pytest.mark.unit
    # check_date and before_date are both strings that can be parsed to dates
    def test_checkdate_before_beforedate_strings(self):
        check_date = "2023-01-01"
        before_date = "2023-01-02"
        assert is_checkdate_before_date(check_date, before_date) == True


class TestIsCheckdateAfterDate:

    @pytest.mark.unit
    # check_date and after_date are both datetime objects
    def test_both_datetime_objects(self):
        check_date = DT.datetime(2023, 10, 1, 12, 0, 0)
        after_date = DT.datetime(2023, 9, 30, 12, 0, 0)
        result = is_checkdate_after_date(check_date, after_date)
        assert result is True

    @pytest.mark.unit
    # check_date and after_date are the same datetime object
    def test_same_datetime_object(self):
        check_date = after_date = DT.datetime(2023, 10, 1, 12, 0, 0)
        result = is_checkdate_after_date(check_date, after_date)
        assert result is False

    @pytest.mark.unit
    # check_date and after_date are the same date object
    def test_same_date_object(self):
        check_date = after_date = DT.date(2023, 10, 1)
        result = is_checkdate_after_date(check_date, after_date)
        assert result is False

    @pytest.mark.unit
    # check_date and after_date are both date objects
    def test_both_date_objects(self):
        check_date = DT.date(2023, 10, 1)
        after_date = DT.date(2023, 9, 30)
        result = is_checkdate_after_date(check_date, after_date)
        assert result is True

    @pytest.mark.unit
    # check_date is a datetime object and after_date is a date object
    def test_checkdate_after_date(self):
        check_date = DT.datetime(2023, 10, 1, 12, 0, 0)
        after_date = DT.date(2023, 9, 30)
        result = is_checkdate_after_date(check_date, after_date)
        assert result is True

    @pytest.mark.unit
    # check_date is a date object and after_date is a datetime object
    def test_checkdate_date_after_datetime(self):
        check_date = DT.date(2023, 10, 1)
        after_date = DT.datetime(2023, 9, 30, 12, 0, 0)
        result = is_checkdate_after_date(check_date, after_date)
        assert result is True

    @pytest.mark.unit
    # check_date is the minimum possible datetime value
    def test_checkdate_min_datetime_value(self):
        check_date = DT.datetime.min
        after_date = DT.datetime(2023, 9, 30, 12, 0, 0)
        result = is_checkdate_after_date(check_date, after_date)
        assert result is False

    @pytest.mark.unit
    # after_date is the maximum possible datetime value
    def test_after_date_is_maximum_datetime_value(self):
        check_date = DT.datetime(2023, 10, 1, 12, 0, 0)
        after_date = DT.datetime.max
        result = is_checkdate_after_date(check_date, after_date)
        assert result is False


class TestIsDateInRange:

    @pytest.mark.unit
    # check_date is within the range of start_date and end_date
    def test_check_date_within_range(self):
        start_date = DT.datetime(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 2)
        end_date = DT.datetime(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == True

    @pytest.mark.unit
    # start_date is after end_date
    def test_start_date_after_end_date(self):
        start_date = DT.datetime(2023, 1, 3)
        check_date = DT.datetime(2023, 1, 2)
        end_date = DT.datetime(2023, 1, 1)
        assert is_date_in_range(start_date, check_date, end_date) == False

    @pytest.mark.unit
    # check_date is before start_date
    def test_check_date_before_start_date(self):
        start_date = DT.datetime(2023, 1, 2)
        check_date = DT.datetime(2023, 1, 1)
        end_date = DT.datetime(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == False

    @pytest.mark.unit
    # check_date is exactly the same as start_date
    def test_check_date_same_as_start_date(self):
        start_date = DT.datetime(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 1)
        end_date = DT.datetime(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == True

    @pytest.mark.unit
    # check_date is exactly the same as end_date
    def test_check_date_same_as_end_date(self):
        start_date = DT.datetime(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 3)
        end_date = DT.datetime(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == True

    @pytest.mark.unit
    # start_date, check_date, and end_date are all DT.datetime objects
    def test_is_date_in_range_with_datetime_objects(self):
        start_date = DT.datetime(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 2)
        end_date = DT.datetime(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == True

    @pytest.mark.unit
    # start_date, check_date, and end_date are all DT.date objects
    def test_is_date_in_range_with_dates_only(self):
        start_date = DT.date(2023, 1, 1)
        check_date = DT.date(2023, 1, 2)
        end_date = DT.date(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == True

    @pytest.mark.unit
    # check_date is after end_date
    def test_check_date_after_end_date(self):
        start_date = DT.datetime(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 4)
        end_date = DT.datetime(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == False

    @pytest.mark.unit
    # start_date, check_date, and end_date are a mix of DT.date and DT.datetime objects
    def test_is_date_in_range_mixed_types(self):
        start_date = DT.date(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 2)
        end_date = DT.date(2023, 1, 3)
        assert is_date_in_range(start_date, check_date, end_date) == True

    @pytest.mark.unit
    # start_date, check_date, and end_date are the same date
    def test_same_date(self):
        same_date = DT.datetime(2023, 1, 1)
        assert is_date_in_range(same_date, same_date, same_date) == True

    @pytest.mark.unit
    # check_date is at the exact boundary of start_date or end_date
    def test_check_date_at_boundary(self):
        start_date = DT.datetime(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 2)
        end_date = DT.datetime(2023, 1, 2)
        assert is_date_in_range(start_date, check_date, end_date) == True

    @pytest.mark.unit
    # start_date and end_date are the same, and check_date is different
    def test_start_end_same_check_different(self):
        start_date = DT.datetime(2023, 1, 1)
        check_date = DT.datetime(2023, 1, 2)
        end_date = DT.datetime(2023, 1, 1)
        assert is_date_in_range(start_date, check_date, end_date) == False

    @pytest.mark.unit
    # check_date is exactly at the transition between two dates (e.g., midnight)
    def test_check_date_at_transition(self):
        start_date = DT.datetime(2023, 1, 1, 23, 59, 59)
        check_date = DT.datetime(2023, 1, 2, 0, 0, 0)
        end_date = DT.datetime(2023, 1, 3, 0, 0, 1)
        assert is_date_in_range(start_date, check_date, end_date) == True


class TestTimezoneAwarenessMixing:

    @pytest.mark.unit
    def test_before_date_timezone_aware_check_date_naive(self):
        check_date = DT.datetime(2023, 5, 1, 12, 0, 0)
        before_date = DT.datetime(2023, 5, 2, 12, 0, 0, tzinfo=DT.timezone.utc)
        assert is_checkdate_before_date(check_date, before_date) is True

    @pytest.mark.unit
    def test_after_date_timezone_aware_check_date_naive(self):
        check_date = DT.datetime(2023, 5, 3, 12, 0, 0, tzinfo=DT.timezone.utc)
        after_date = DT.datetime(2023, 5, 2, 12, 0, 0)
        assert is_checkdate_after_date(check_date, after_date) is True

    @pytest.mark.unit
    def test_date_in_range_mixed_awareness(self):
        start_date = DT.datetime(2023, 5, 1, 0, 0, 0, tzinfo=DT.timezone.utc)
        check_date = DT.datetime(2023, 5, 2, 12, 0, 0)
        end_date = DT.datetime(2023, 5, 3, 23, 59, 59, tzinfo=DT.timezone.utc)
        assert is_date_in_range(start_date, check_date, end_date) is True


class TestWeeksBetweenDates:

    @pytest.mark.unit
    def test_weeks_between_dates_mixed_awareness(self):
        date1 = DT.datetime(2023, 1, 1, 12, 0, 0, tzinfo=DT.timezone.utc)
        date2 = DT.datetime(2023, 1, 8, 11, 0, 0)
        assert weeks_between_dates(date1, date2) == 1

    @pytest.mark.unit
    def test_weeks_between_dates_string_inputs(self):
        assert weeks_between_dates("2023-01-01", "2023-01-15") == 2

